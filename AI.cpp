/*
 * Copyright 2023 University of Michigan EECS183
 *
 * AI.cpp
 * Project UID 848fee0125dbb5eb53ed294f20dbef81
 *
 * <#Names#>
 * <#Uniqnames#>
 *
 * Final Project - Elevators
 */

#include "AI.h"
#include "Floor.h"
#include "Utility.h"
#include <cassert>

// This file is used only in the Reach, not the Core.
// You do not need to make any changes to this file for the Core

/*
* Requires: buildingState is a valid state representing the current building
* Modifies: Nothing
* Effects:  Returns a string that represents the decision the AI makes 
*           given the current state of the building, which it reads 
*           from buildingState.
*           The string should share the exact format as a 
*           human player's move input.
*/
string getAIMoveString(const BuildingState& buildingState) {
    string move;

    // if one or more elevator not moving, pick up on floor with the most total anger
    int priorityElevator = -1; // which elevator should be moved this turn
    int highestAnger = 0;
    bool goodPickup = false;

    for (int i = 0; i < NUM_ELEVATORS; i++) {
        int elevCurrFloor = buildingState.elevators[i].currentFloor;
        int totalAnger = 0;
        for (int j = 0; j < buildingState.floors[elevCurrFloor].numPeople; j++) {
            totalAnger += buildingState.floors[elevCurrFloor].people[j].angerLevel;
        }
        if (totalAnger >= highestAnger
            && !buildingState.elevators[i].isServicing) {
            highestAnger = totalAnger;
            priorityElevator = i;
            goodPickup = (totalAnger > 0);
        }
    }

    // if we found an idle elevator sitting on an angry floor, do a pickup
    if (goodPickup) {
        move = "e";
        move += char('0' + priorityElevator);
        move += 'p';
        return move;
    }
    // after checking above conditions, AI will then check next condition

    // if any elevator isn't moving, send one toward an angry floor
    priorityElevator = -1; // reset priority elevator
    int bestScore = -1000000; 
    int targetFloor = -1;

    for (int i = 0; i < NUM_ELEVATORS; i++) {
        if (buildingState.elevators[i].isServicing) {
            continue;
        }
        int curFloor = buildingState.elevators[i].currentFloor;

        for (int f = 0; f < NUM_FLOORS; f++) {
            int floorAnger = 0;
            for (int j = 0; j < buildingState.floors[f].numPeople; j++) {
                floorAnger += buildingState.floors[f].people[j].angerLevel;
            }
            if (floorAnger == 0) {
                continue;
            }

            int dist = abs(curFloor - f);
            int score = floorAnger - dist; // simple heuristic: closer + angrier is better

            if (score > bestScore) {
                bestScore = score;
                priorityElevator = i;
                targetFloor = f;
            }
        }
    }

    if (priorityElevator != -1 && targetFloor != -1) {
        move = "e";
        move += char('0' + priorityElevator);
        move += 'f';
        move += to_string(targetFloor);
        return move;
    }

    // no one waiting anywhere, just pass
    return "";
}

/*
* Requires: buildingState is a valid state representing the current building
*           move is a pickup move that was generated by getAIMoveString()
*           floorToPickup represents the floor the pickup move occurred.
* Modifies: Nothing
* Effects:  Returns a string representing which people indices 
*           should be picked up. The string should share the exact format 
*           as a human player's pickup list input.
*/
string getAIPickupList(const Move& move, const BuildingState& buildingState,
                       const Floor& floorToPickup) {
    // Pickup list and array to keep track of what person should be picked up
    string list;

    // weighting for person parameters
    const double angerWeight = 1;
    const double distanceWeight = 1;
    
    // get total anger of up and down people and make array of indices for up/down people
    Person tempPerson;
    int totalAngerUp = 0;
    int totalAngerDown = 0;
    string upList;
    string downList;

    for (int i = 0; i < floorToPickup.getNumPeople(); i++) {
        tempPerson = floorToPickup.getPersonByIndex(i);
        if (tempPerson.getTargetFloor() > tempPerson.getCurrentFloor()) {
            totalAngerUp += static_cast<int>(angerWeight * tempPerson.getAngerLevel());
            upList += char('0' + i);
        }
        else {
            totalAngerDown += static_cast<int>(angerWeight * tempPerson.getAngerLevel());
            downList += char('0' + i);
        }
    }

    // take the list with the most anger
    if (totalAngerDown > totalAngerUp) {
        list = downList;
    } else {
        list = upList;
    }

    // respect elevator capacity
    if (static_cast<int>(list.size()) > ELEVATOR_CAPACITY) {
        list = list.substr(0, ELEVATOR_CAPACITY);
    }

    // fallback: if list somehow empty but there are people, just pick first person
    if (list.empty() && floorToPickup.getNumPeople() > 0) {
        list = "0";
    }
        
    return list;
}
