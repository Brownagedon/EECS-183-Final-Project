/*
 * Copyright 2023 University of Michigan EECS183
 *
 * AI.cpp
 * Project UID 848fee0125dbb5eb53ed294f20dbef81
 *
 * <#Names#>
 * <#Uniqnames#>
 *
 * Final Project - Elevators
 */

#include "AI.h"
#include "Floor.h"
#include "Utility.h"
#include <cassert>

// This file is used only in the Reach, not the Core.
// You do not need to make any changes to this file for the Core

/*
* Requires: buildingState is a valid state representing the current building
* Modifies: Nothing
* Effects:  Returns a string that represents the decision the AI makes 
*           given the current state of the building, which it reads 
*           from buildingState.
*           The string should share the exact format as a 
*           human player's move input.
*/
string getAIMoveString(const BuildingState& buildingState) {
    string move;

    // if one or more elevator not moving, pick up on floor with the most total anger
    int priorityElevator = -1;
    int highestAnger = 0;
    bool goodPickup = false;

    for (int i = 0; i < NUM_ELEVATORS; i++) {
        int elevCurrFloor = buildingState.elevators[i].currentFloor;
        int totalAnger = 0;
        for (int j = 0; j < buildingState.floors[elevCurrFloor].numPeople; j++) {
            totalAnger += buildingState.floors[elevCurrFloor].people[j].angerLevel;
        }
        if (totalAnger >= highestAnger 
            && !buildingState.elevators[i].isServicing) {
            highestAnger = totalAnger;
            priorityElevator = i;
            goodPickup = true;
        }
    }
    if (goodPickup) {
        move = "e";
        move += '0' + priorityElevator;
        move += 'p';
        return move;
    }

    // if given elevator isn't moving, claim a spot to go to. highest priority wins the move
    priorityElevator = -1;
    for (int i = 0; i < NUM_ELEVATORS; i++) {

    }

    return move;
}

/*
* Requires: buildingState is a valid state representing the current building
*           move is a pickup move that was generated by getAIMoveString()
*           floorToPickup represents the floor the pickup move occurred.
* Modifies: Nothing
* Effects:  Returns a string representing which people indices 
*           should be picked up. The string should share the exact format 
*           as a human player's pickup list input.
*/
string getAIPickupList(const Move& move, const BuildingState& buildingState, 
                       const Floor& floorToPickup) {
    // Pickup list and array to keep track of what person should be picked up
    string list;

    // weighting for person parameters
    const double angerWeight = 1;
    const double distanceWeight = 1;
    
    // get total anger of up and down people and make array of indices for up/down people
    Person tempPerson;
    int totalAngerUp = 0;
    int totalAngerDown = 0;
    string upList;
    string downList;

    for (int i = 0; i < floorToPickup.getNumPeople(); i++) {
        tempPerson = floorToPickup.getPersonByIndex(i);
        if (tempPerson.getTargetFloor() > tempPerson.getCurrentFloor()) {
            totalAngerUp += tempPerson.getAngerLevel();
            upList += i + '0';
        } else {
            totalAngerDown += tempPerson.getAngerLevel();
            downList += i + '0';
        }
        
    }

    // take the list with the most anger
    if (totalAngerDown > totalAngerUp) {
        list = downList;
    } else {
        list = upList;
    }
        
    return list;
}

int getFloorHigherAnger(Floor floorIn) {
    // get total anger of up and down people and make array of indices for up/down people
    Person tempPerson;
    int totalAngerUp = 0;
    int totalAngerDown = 0;

    for (int i = 0; i < floorIn.getNumPeople(); i++) {
        tempPerson = floorIn.getPersonByIndex(i);
        if (tempPerson.getTargetFloor() > tempPerson.getCurrentFloor()) {
            totalAngerUp += tempPerson.getAngerLevel();
        } else {
            totalAngerDown += tempPerson.getAngerLevel();
        }
    }
    if (totalAngerDown > totalAngerUp)
        return -totalAngerDown;
    else
        return totalAngerUp;
}